"use client";
import { useEffect, useState } from "react";
import { Controller, useForm } from "react-hook-form";
import { yupResolver } from "@hookform/resolvers/yup";
import * as yup from "yup";
// MUI
import Box from "@mui/material/Box";
import Card from "@mui/material/Card";
import Grid from "@mui/material/Grid2";
import MenuItem from "@mui/material/MenuItem";
import LoadingButton from "@mui/lab/LoadingButton";
// GLOBAL CUSTOM COMPONENTS
import DropZone from "components/DropZone";
import FlexBox from "components/flex-box/flex-box";
import { Checkbox, FormProvider, TextField } from "components/form-hook";

import { v4 as uuidv4 } from "uuid";
import { addWatermark, compressImage } from "utils/helpers";
// STYLED COMPONENTS
import { UploadImageBox, StyledClear } from "../styles";
import {
  useAddCategoryMutation,
  useDeleteCategoryMutation,
  useDeleteImageMutation,
  useGetMegaMenuCategoriesQuery,
  useListAllCategoriesQuery,
  useUpdateCategoryMutation,
  useUploadImageMutation,
} from "app/store/services"; // this hook is auto-generated by RTK Query
import axios from "axios";
import { ClosedCaptionDisabledOutlined } from "@mui/icons-material";
import { getFileType, uploadToS3 } from "utils/s3Helper";
import { useSnackbar } from "notistack";
import { useRouter } from "next/navigation";
import { ImageGallery } from "components/image-gallery";
import { EXCLUDED_CATEGORY_ID } from "utils/constants";
import { Button } from "@mui/material";
// FORM VALIDATION
const validationSchema = yup.object().shape({
  name: yup.string().required("Category name is required"),
  title: yup.string(),
  description: yup.string(),
  image: yup.string().url(),
  slug: yup.string(),
  parentId: yup.string().nullable(),
  level: yup.number(),
  isActive: yup.boolean(),
  displayOrder: yup.number()
    .min(1, "Display order must be at least 1")
    .required("Display order is required"),
  isRecentlyAdded: yup.boolean(),
  hasChildren: yup.boolean(),
  hasParts: yup.boolean(),
  modelNumbers: yup.array().of(yup.string()),
  attributes: yup.object(),
});

export default function CategoryForm({ initialValues, onSuccess, mode }) {
  const { enqueueSnackbar } = useSnackbar();
  // console.log("initial values", initialValues, mode);
  const [files, setFiles] = useState([]);
  const [subCategory, setSubCategory] = useState([]);
  const [galleryOpen, setGalleryOpen] = useState(false);
  const [addCategory, { isLoading: adding }] = useAddCategoryMutation();
  const [updateCategory, { isLoading: updating }] = useUpdateCategoryMutation();
  const router = useRouter();
  // const { data, isLoading, error } = useListAllCategoriesQuery();
  const { data, error, isLoading } = useGetMegaMenuCategoriesQuery();

  // Calculate maximum display order for the selected parent category
  const calculateMaxDisplayOrder = (parentId, currentCategoryId) => {
    if (!subCategory || subCategory.length === 0) return 1;

    // Get siblings (categories with the same parent)
    const siblings = subCategory.filter(cat => cat.parentId === parentId);

    // If no siblings, max order is 1
    if (siblings.length === 0) return 1;

    // If editing existing category, exclude it from sibling count
    const siblingCount = currentCategoryId
      ? siblings.filter(cat => cat._id !== currentCategoryId).length
      : siblings.length;

    // Max order is current sibling count + 1 (for new position)
    return siblingCount + 1;
  };

  const [
    uploadImageHandle,
    { isLoading: uploadingImage, error: uploadingImageError },
  ] = useUploadImageMutation();
  const [
    deleteImageHandle,
    { isLoading: deletingImage, error: deletingImageError },
  ] = useDeleteImageMutation();

  // console.log("category formmmm", data.data.categories, isLoading, error);
  useEffect(() => {
    if (!isLoading && data.success) {
      // console.log("22222222")
      // setSubCategory(data?.data?.categories);
      setSubCategory(data?.data);
    }
    if (error) {
      console.error("Error fetching categories:", error);
    }
  }, [data, isLoading, error]);

  const parentCategory = subCategory.find(
    (cat) => cat._id === initialValues?.parentId
  );

  // console.log("!!!!!!!", data?.data?.categories);
  const methods = useForm({
    defaultValues: {
      name: "",
      title: "",
      description: "",
      image: "",
      slug: "",
      parentId: null,
      level: 1,
      isActive: true,
      displayOrder: 1,
      isRecentlyAdded: false,
      hasChildren: false,
      hasParts: false,
      modelNumbers: [],
      attributes: {},
      ...initialValues, // for edit case
    },
    resolver: yupResolver(validationSchema),
  });
  const { handleSubmit, reset } = methods;

  useEffect(() => {
    if (initialValues) {
      reset(initialValues);
      if (initialValues.image) {
        setFiles([
          {
            name: initialValues.image,
            preview: initialValues.image,
          },
        ]);
      }
    }
  }, [initialValues, reset]);

  // Auto-update display order when parent category changes
  const parentIdValue = methods.watch("parentId");
  useEffect(() => {
    // Wait until category list is loaded to calculate real max
    if (!subCategory || subCategory.length === 0) return;
    if (parentIdValue === undefined) return;

    // Normalize values: treat empty string as null for top-level
    const normalizedParentId = parentIdValue === "" ? null : parentIdValue;
    const normalizedInitialParentId = (initialValues?.parentId ?? null) === "" ? null : (initialValues?.parentId ?? null);

    // In edit mode, do not clamp on initial load unless parent actually changes
    if (mode === "edit" && normalizedParentId === normalizedInitialParentId) return;

    const maxOrder = calculateMaxDisplayOrder(normalizedParentId, initialValues?.id);
    const currentOrder = Number(methods.getValues("displayOrder")) || 1;
    if (currentOrder > maxOrder) {
      methods.setValue("displayOrder", maxOrder);
    }
  }, [parentIdValue, initialValues?.id, initialValues?.parentId, mode, subCategory]);

  const handleSubmitForm = handleSubmit(async (values) => {
    const parentCategory = subCategory?.find(
      (cat) => cat._id === values.parentId
    );

    // Determine the correct level
    const level = parentCategory ? parentCategory.level + 1 : 1;

    // Ensure display order is a number
    const displayOrder = parseInt(values.displayOrder) || 1;

    const payload = {
      ...values,
      level,
    
      // For create, backend expects displayOrder; for update, it expects updatedDisplayOrder
      ...(mode === "edit" && initialValues?.id
        ? { id: initialValues.id, updatedDisplayOrder: displayOrder }
        : { displayOrder }),
    };

    // console.log("payload", payload, mode );
    try {
      if (mode === "edit" && initialValues?.id) {
        //  console.log(" beforee resssss")
        const res = await updateCategory(payload).unwrap();
        // console.log("ressss fro update", res)
        if (res?.success === true) {
          // console.log("resssss",res)
          enqueueSnackbar("Category Updated successfully!", {
            variant: "success",
          });
          if (onSuccess) {
            onSuccess();
          } else {
            router.push("/admin/categories");
          }
        } else {
          enqueueSnackbar(res.message, { variant: "error" });
        }
      } else {
        const res = await addCategory(payload).unwrap();
        // console.log("resssss", res)
        if (res?.success === true) {
          // console.log("success hereeeee")
          enqueueSnackbar("Category Added successfully!", {
            variant: "success",
          });
          if (onSuccess) {
            onSuccess();
          } else {
            router.push("/admin/categories");
          }
        } else {
          enqueueSnackbar(res.message, { variant: "error" });
        }
      }
      setFiles([]);
      reset();
    } catch (error) {
      console.error("Submit error", error);
    }
  });

  const handleChangeDropZone = async (files) => {
    // console.log("FILES RECEIVED:", files);
    const file = files[0];
    if (!file) {
      console.error("No file selected.");
      return;
    }

    if (file.size > 20 * 1024 * 1024) {
      console.error(`${file.name} exceeds the maximum size of 20 MB.`);
      return;
    }

    try {
      const uniqueId = uuidv4();
      // console.log("s3 starting");

      const compressedFile = await compressImage(file);
      const watermarkedImageUrl = await addWatermark(compressedFile, "");
      const response = await fetch(watermarkedImageUrl);
      const blob = await response.blob();
      //
      // console.log("before s3data", `${uniqueId}-${file.name}`, file.type);

      // Get category name for filename
      const categoryName = methods.getValues('name') || 'category';
      
      // Create descriptive filename with metadata
      const cleanCategoryName = categoryName.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
      const descriptiveFileName = `category-${cleanCategoryName}-${uniqueId}-${file.name}`;
      
      // Get S3 pre-signed URL
      const s3data = await uploadImageHandle({
        fileName: descriptiveFileName,
        fileType: file.type,
        imageType: 'category',
      }).unwrap();

      // Upload using helper
      const uploadedUrl = await uploadToS3({
        url: s3data.url,
        blob,
        fileType: file.type,
      });

      if (uploadedUrl) {
        const finalImageUrl = uploadedUrl.split("?")[0]; // or use full URL
        // console.log("âœ… Uploaded image URL:", finalImageUrl);

        // Show thumbnail
        setFiles([{ name: file.name, preview: finalImageUrl }]);
        methods.setValue("image", finalImageUrl); // if using react-hook-form
      } else {
        console.warn("Image upload failed");
      }
    } catch (error) {
      console.error("Image upload failed", error);
    }
  };
  // console.log("files s3", files);

  // HANDLE DELETE UPLOAD IMAGE
  const handleFileDelete = (file) => async () => {
    try {
      // console.log("delete called");

      const fileDetails = getFileType(file);
      // console.log("imageee", file, fileDetails);
      await deleteImageHandle({
        fileName: fileDetails.fileName,
        fileType: fileDetails.fileType,
      });

      setFiles([]);
      methods.setValue("image", "");

      // console.log("delete", res);
    } catch (err) {
      console.error("Image delete failed", err);
    }
  };

  // Handle image gallery selection
  const handleGalleryImageSelect = (imageUrl) => {
    setFiles([{ name: imageUrl.split("/").pop(), preview: imageUrl }]);
    methods.setValue("image", imageUrl);
    setGalleryOpen(false);
    enqueueSnackbar("Image selected from gallery!", { variant: "success" });
  };

  // console.log("categoty modeee", mode, subCategory);
  return (
    <Card className="p-3">
      <FormProvider methods={methods} onSubmit={handleSubmitForm}>
        <Grid container spacing={3} direction="column">

          {/* Name & Display Order side by side on sm+, full width on xs */}
          <Grid item xs={12} sm={6}>
            <TextField
              fullWidth
              name="name"
              label="Name"
              color="info"
              size="medium"
              placeholder="Name"
              InputProps={{
                readOnly: mode === "view",
                sx: mode === "view" ? {
                  "& .MuiInputBase-input": {
                    color: "black",
                    WebkitTextFillColor: "black"
                  },
                  "& .MuiOutlinedInput-root": {
                    "& fieldset": {
                      borderColor: "black"
                    },
                    "&:hover fieldset": {
                      borderColor: "black"
                    }
                  }
                } : {}
              }}
            />
          </Grid>
          {/* Parent Category & Description side by side on sm+, full width on xs */}
          <Grid item xs={12} sm={6}>
            <TextField
              name="parentId"
              select
              label="Parent Category"
              fullWidth
              InputProps={{
                readOnly: mode === "view",
                sx: mode === "view" ? {
                  "& .MuiInputBase-input": {
                    color: "black",
                    WebkitTextFillColor: "black"
                  },
                  "& .MuiOutlinedInput-root": {
                    "& fieldset": {
                      borderColor: "black"
                    },
                    "&:hover fieldset": {
                      borderColor: "black"
                    }
                  }
                } : {}
              }}
            >
              <MenuItem value="">-- No Parent --</MenuItem>
              {isLoading ? (
                <MenuItem disabled>Loading categories...</MenuItem>
              ) : (
                subCategory.map((cat) => (
                  <MenuItem key={cat._id} value={cat._id}>
                    {cat.name || cat.title}
                  </MenuItem>
                ))
              )}
            </TextField>
          </Grid>

          <Grid item xs={12} sm={6}>
            {(() => {
              const maxOrder = calculateMaxDisplayOrder(
                methods.watch("parentId"),
                initialValues?.id
              );
              const isExcluded = initialValues?.id === EXCLUDED_CATEGORY_ID; // only parent
              return (
                <TextField
                  name="displayOrder"
                  fullWidth
                  label="Display Order"
                  color="info"
                  size="medium"
                  type="number"
                  placeholder="1"
                  inputProps={{ min: 1, max: maxOrder }}
                  helperText={isExcluded ? "Display order is not applicable for DeletedCategories." : `Position in the category list (1 to ${maxOrder})`}
                  disabled={isExcluded}
                  InputProps={{
                    readOnly: mode === "view",
                    sx: mode === "view" ? {
                      "& .MuiInputBase-input": {
                        color: "black",
                        WebkitTextFillColor: "black"
                      },
                      "& .MuiOutlinedInput-root": {
                        "& fieldset": {
                          borderColor: "black"
                        },
                        "&:hover fieldset": {
                          borderColor: "black"
                        }
                      }
                    } : {}
                  }}
                  onChange={mode === "view" ? undefined : (e) => {
                    const value = parseInt(e.target.value);
                    if (!Number.isNaN(value) && value >= 1 && value <= maxOrder) {
                      methods.setValue("displayOrder", value);
                    }
                  }}
                />
              );
            })()}
          </Grid>



          <Grid item xs={12} sm={6}>
            <TextField
              fullWidth
              name="description"
              label="Description"
              color="info"
              size="medium"
              multiline
              rows={3}
              placeholder="Category description"
              InputProps={{
                readOnly: mode === "view",
                sx: mode === "view" ? {
                  "& .MuiInputBase-input": {
                    color: "black",
                    WebkitTextFillColor: "black"
                  },
                  "& .MuiOutlinedInput-root": {
                    "& fieldset": {
                      borderColor: "black"
                    },
                    "&:hover fieldset": {
                      borderColor: "black"
                    }
                  }
                } : {}
              }}
            />
          </Grid>

          {/* File Upload (always full width) */}
          <Grid item xs={12}>
            <FlexBox flexDirection="column" gap={2}>
              <DropZone onChange={handleChangeDropZone} disabled={mode === "view"} />
              {mode !== "view" && (
                <Button
                  variant="outlined"
                  color="primary"
                  onClick={() => setGalleryOpen(true)}
                  sx={{ alignSelf: "flex-start" }}
                >
                  Choose from Gallery
                </Button>
              )}
            </FlexBox>
            <FlexBox flexDirection="row" mt={2} flexWrap="wrap" gap={1}>
              {files.map((file, index) => (
                <UploadImageBox key={index}>
                  <Box
                    component="img"
                    alt="product"
                    src={file.preview}
                    width="100%"
                  />
                  {mode !== "view" && (
                    <StyledClear onClick={handleFileDelete(file)} />
                  )}
                </UploadImageBox>
              ))}
            </FlexBox>
          </Grid>

          {/* Submit Button (always full width) */}
          <Grid item xs={12} md={6}>
            {mode !== "view" ? (
              <LoadingButton
                loading={adding || updating}
                variant="contained"
                color="info"
                type="submit"
              // fullWidth
              >
                {mode === "edit" ? "Update Category" : "Save Category"}
              </LoadingButton>
            ) : (
              <LoadingButton
                variant="contained"
                color="info"
                type="button"
                onClick={(e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  console.log("Close button clicked");
                  try {
                    onSuccess();
                  } catch (error) {
                    console.error("Error:", error);
                    window.location.href = "/admin/categories";
                  }
                }}
              >
                Close
              </LoadingButton>
            )}
          </Grid>
        </Grid>
      </FormProvider>
      
      {/* Image Gallery Modal */}
      <ImageGallery
        open={galleryOpen}
        onClose={() => setGalleryOpen(false)}
        onSelectImage={handleGalleryImageSelect}
        selectedImageUrl={methods.watch("image")}
      />
    </Card>


  );
}
